<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å¿å¿æˆ‘æˆ‘å‰µè§’å°å¹«æ‰‹</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;600;700&family=Noto+Sans+TC:wght@300;400;500;700&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            sans: ['"Noto Sans TC"', 'system-ui', 'sans-serif'],
            serif: ['"Noto Serif TC"', 'serif'],
          },
          colors: {
            'page-bg': 'var(--page-bg)',
            'card-bg': 'var(--card-bg)',
            'sidebar-bg': 'var(--sidebar-bg)',
            'text-main': 'var(--text-main)',
            'text-sub': 'var(--text-sub)',
            'focus': 'var(--focus-color)',
            'btn-bg': 'var(--btn-bg)',
            'btn-text': 'var(--btn-text)',
            'border-color': 'var(--border-color)',
          },
          boxShadow: {
            'glow': 'var(--shadow-glow)',
          }
        },
      },
    }
  </script>
  <style>
    /* Custom Scrollbar for Sidebar */
    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    
    /* Base Transitions */
    body {
      transition: background-color 0.5s ease, color 0.5s ease;
    }
  </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="react,typescript">
    const { useState, useEffect, createContext, useContext, useCallback } = React;

    // --- Types & Constants ---

    const THEMES = {
      pink: {
        '--page-bg': '#fff0f5',
        '--card-bg': 'rgba(255, 255, 255, 0.9)',
        '--sidebar-bg': 'rgba(255, 255, 255, 0.95)',
        '--text-main': '#2c3e50',
        '--text-sub': '#64748b',
        '--border-color': 'rgba(0,0,0,0.08)',
        '--focus-color': '#ff7eb3',
        '--btn-bg': '#ff7eb3',
        '--btn-text': '#fff',
        '--shadow-glow': '0 0 15px rgba(255, 126, 179, 0.4)',
      },
      cream: {
        '--page-bg': '#fdfcf0',
        '--card-bg': 'rgba(255, 255, 255, 0.9)',
        '--sidebar-bg': 'rgba(255, 255, 255, 0.95)',
        '--text-main': '#2c3e50',
        '--text-sub': '#64748b',
        '--border-color': 'rgba(0,0,0,0.08)',
        '--focus-color': '#ffac6e',
        '--btn-bg': '#ffac6e',
        '--btn-text': '#fff',
        '--shadow-glow': '0 0 15px rgba(255, 172, 110, 0.4)',
      },
      mint: {
        '--page-bg': '#f0fff9',
        '--card-bg': 'rgba(255, 255, 255, 0.9)',
        '--sidebar-bg': 'rgba(255, 255, 255, 0.95)',
        '--text-main': '#2c3e50',
        '--text-sub': '#64748b',
        '--border-color': 'rgba(0,0,0,0.08)',
        '--focus-color': '#4cd9a4',
        '--btn-bg': '#4cd9a4',
        '--btn-text': '#fff',
        '--shadow-glow': '0 0 15px rgba(76, 217, 164, 0.4)',
      },
      lavender: {
        '--page-bg': '#f7f2ff',
        '--card-bg': 'rgba(255, 255, 255, 0.9)',
        '--sidebar-bg': 'rgba(255, 255, 255, 0.95)',
        '--text-main': '#2c3e50',
        '--text-sub': '#64748b',
        '--border-color': 'rgba(0,0,0,0.08)',
        '--focus-color': '#b185ff',
        '--btn-bg': '#b185ff',
        '--btn-text': '#fff',
        '--shadow-glow': '0 0 15px rgba(177, 133, 255, 0.4)',
      },
      sky: {
        '--page-bg': '#f0f8ff',
        '--card-bg': 'rgba(255, 255, 255, 0.9)',
        '--sidebar-bg': 'rgba(255, 255, 255, 0.95)',
        '--text-main': '#2c3e50',
        '--text-sub': '#64748b',
        '--border-color': 'rgba(0,0,0,0.08)',
        '--focus-color': '#6ab0ff',
        '--btn-bg': '#6ab0ff',
        '--btn-text': '#fff',
        '--shadow-glow': '0 0 15px rgba(106, 176, 255, 0.4)',
      },
      lemon: {
        '--page-bg': '#fffff0',
        '--card-bg': 'rgba(255, 255, 255, 0.9)',
        '--sidebar-bg': 'rgba(255, 255, 255, 0.95)',
        '--text-main': '#2c3e50',
        '--text-sub': '#64748b',
        '--border-color': 'rgba(0,0,0,0.08)',
        '--focus-color': '#facc15',
        '--btn-bg': '#facc15',
        '--btn-text': '#5c4e00',
        '--shadow-glow': '0 0 15px rgba(250, 204, 21, 0.4)',
      },
      grey: {
        '--page-bg': '#f8f9fa',
        '--card-bg': 'rgba(255, 255, 255, 0.9)',
        '--sidebar-bg': 'rgba(255, 255, 255, 0.95)',
        '--text-main': '#2c3e50',
        '--text-sub': '#64748b',
        '--border-color': 'rgba(0,0,0,0.08)',
        '--focus-color': '#8d99ae',
        '--btn-bg': '#8d99ae',
        '--btn-text': '#fff',
        '--shadow-glow': '0 0 15px rgba(141, 153, 174, 0.4)',
      },
      black: {
        '--page-bg': '#121212',
        '--card-bg': 'rgba(30, 30, 30, 0.9)',
        '--sidebar-bg': 'rgba(25, 25, 25, 0.95)',
        '--text-main': '#e0e0e0',
        '--text-sub': '#9ca3af',
        '--border-color': 'rgba(255,255,255,0.12)',
        '--focus-color': '#aaaaaa',
        '--btn-bg': '#555555',
        '--btn-text': '#fff',
        '--shadow-glow': '0 0 15px rgba(170, 170, 170, 0.4)',
      },
    };

    const STAGE_LABELS = {
      acquaintance: 'ç†Ÿäººéšæ®µ',
      friend: 'æœ‹å‹éšæ®µ',
      crush: 'å¿ƒå‹•éšæ®µ',
      lover: 'æˆ€äººéšæ®µ',
      marriage: 'çµå©šéšæ®µ',
    };

    const TEMPLATE_TYPES = {
      basicInfo: 'ä¸€ã€åŸºæœ¬è³‡è¨Š',
      personality: 'äºŒã€æ€§æ ¼',
      speechStyle: 'ä¸‰ã€èªªè©±é¢¨æ ¼èˆ‡ç¿’æ…£',
      extra: 'é™„åŠ è³‡è¨Š',
      event: 'å‰µä½œè€…äº‹ä»¶',
    };

    const DEFAULT_FIELDS = {
      charName: '',
      charCategory: '',
      charAge: '',
      charJob: '',
      charQuote: '',
      charDesc: '',
      charTags: '',
      creatorNote: '',
      basicInfo: '',
      personality: '',
      speechStyle: '',
      firstScene: '',
      sampleDialogue: '',
      likes: '',
      dislikes: '',
      birthday: '',
      gender: 'æœªè¨­ç½®',
      modelType: 'gemini-3-pro',
      promptRole: '',
      promptGuideline: '',
    };

    const DEFAULT_GAME_MANAGEMENT = {
      info: { title: '', intro: '' },
      stories: []
    };

    // --- Helpers ---

    const limitText = (text, max) => {
      const t = text || '';
      return t.trim().length > max ? t.trim().slice(0, max) : t.trim();
    };

    const estimateTextTokens = (text) => {
      let total = 0;
      for (const ch of text || '') {
        if (/\s/.test(ch)) continue;
        if (/[\u3400-\u4DBF\u4E00-\u9FFF]/.test(ch)) {
          total += 2;
        } else {
          total += 1;
        }
      }
      return total;
    };

    const estimatePromptTokens = (role, guide) => {
      return estimateTextTokens(role) + estimateTextTokens(guide);
    };

    const generateMarkdown = (data) => {
      const { fields, extras, events, gameManagement } = data;
      const lines = [];

      const addLine = (str) => lines.push(str);
      const addMainHeader = (title) => {
        lines.push('');
        lines.push(`# ${title}`);
      };
      const addSubHeader = (title) => {
        lines.push('');
        lines.push(`## ${title}`);
      };
      const addSubSubHeader = (title) => {
        lines.push('');
        lines.push(`### ${title}`);
      }
      const addProp = (key, val) => {
        if (val) lines.push(`- ${key}ï¼š${val}`);
      };

      // --- Character Info ---
      addMainHeader('è§’è‰²è³‡è¨Š');
      addProp('åç¨±', fields.charName || "ï¼ˆæœªå‘½åï¼‰");
      addProp('åˆ†é¡', limitText(fields.charCategory, 100));
      if (fields.gender && fields.gender !== 'æœªè¨­ç½®') addProp('æ€§åˆ¥', fields.gender);
      addProp('å¹´é½¡', limitText(fields.charAge, 15));
      addProp('è·æ¥­', limitText(fields.charJob, 15));
      addProp('ç”Ÿæ—¥', fields.birthday);
      
      if (fields.charTags) {
        const tagsFormatted = fields.charTags.split(/[,ï¼Œ\s]+/).filter(Boolean).map(t => "#" + t.replace(/^#/, "")).join(" ");
        if (tagsFormatted) addProp('æ¨™ç±¤', tagsFormatted);
      }

      if (fields.charQuote) {
        addProp('ä¸€å¥è©±', limitText(fields.charQuote, 80));
      }

      if (fields.charDesc) {
        addSubHeader('æ•˜è¿°');
        addLine(limitText(fields.charDesc, 700));
      }

      if (fields.creatorNote) {
        addSubHeader('å‰µä½œè€…ç­†è¨˜');
        addLine(limitText(fields.creatorNote, 200));
      }

      // --- Core Stats ---
      addSubHeader('åŸºæœ¬è³‡è¨Š');
      addLine(limitText(fields.basicInfo, 700) || "ï¼ˆå°šæœªå¡«å¯«ï¼‰");

      addSubHeader('æ€§æ ¼');
      addLine(limitText(fields.personality, 700) || "ï¼ˆå°šæœªå¡«å¯«ï¼‰");

      addSubHeader('èªªè©±é¢¨æ ¼èˆ‡ç¿’æ…£');
      addLine(limitText(fields.speechStyle, 700) || "ï¼ˆå°šæœªå¡«å¯«ï¼‰");

      // --- Config ---
      if (fields.modelType || fields.promptRole || fields.promptGuideline) {
        addMainHeader('æ¨¡å‹èˆ‡ Prompt è¨­å®š');
        if (fields.modelType) {
          const modelMap = { 
            'gemini-3-pro': 'Gemini 3 Pro', 
            'claude-sonnet-4.5': 'Claude Sonnet 4.5', 
            'claude-haiku-4.5': 'Claude Haiku 4.5' 
          };
          addProp('æ¨¡å‹', modelMap[fields.modelType] || fields.modelType);
        }
        const tokens = estimatePromptTokens(fields.promptRole, fields.promptGuideline);
        addProp('é ä¼° token', `${tokens}ï¼ˆåƒ…ä¾›åƒè€ƒï¼‰`);
        
        if (fields.promptRole) {
          addSubHeader('Role');
          addLine(fields.promptRole);
        }
        if (fields.promptGuideline) {
          addSubHeader('Response Guideline');
          addLine(fields.promptGuideline);
        }
      }

       // --- Game Management ---
      if (gameManagement) {
        addMainHeader('éŠæˆ²ç®¡ç†');
        
        addSubHeader('éŠæˆ²ä»‹ç´¹');
        addProp('æ¨™é¡Œ', limitText(gameManagement.info.title, 30));
        addProp('ä»‹ç´¹', limitText(gameManagement.info.intro, 30));

        addSubHeader('ç§å¯†ç‰©èª');
        if (gameManagement.stories.length === 0) {
          addLine("- ï¼ˆç„¡ï¼‰");
        } else {
          gameManagement.stories.forEach((story, idx) => {
            // æŒ‰ç…§è¦æ±‚æ ¼å¼: ### [éšæ®µ] æ¨™é¡Œ
            addSubSubHeader(`[${STAGE_LABELS[story.stage] || story.stage}] ${limitText(story.title, 30)}`);
            addProp('æç¤º', limitText(story.unlockHint, 60));
            addProp('å¥½æ„Ÿåº¦', story.affinityScore.toString());
            addProp('åˆ†ç´š', story.rating === 'adult' ? 'æˆäººé™å®š' : 'æ‰€æœ‰å¹´é½¡');
            addProp('å–å¾—æ–¹å¼', story.access === 'paid' ? 'ä»˜è²» (10æœé†¬)' : 'å…è²»');
            
            lines.push(`- å…§å®¹ï¼š`);
            lines.push(limitText(story.content, 2000));

            if (story.hasEndings && story.endings.length > 0) {
              lines.push(`- å¤šé‡çµå±€ï¼š`);
              story.endings.forEach((end, eIdx) => {
                lines.push(`  - [é¸é …${eIdx+1}] ${limitText(end.option, 100)} (å¥½æ„Ÿ${end.affinity > 0 ? '+' : ''}${end.affinity})`);
                lines.push(`    çµæœï¼š${limitText(end.content, 500)}`);
              });
            }
          });
        }
      }

      // --- Scene ---
      if (fields.firstScene) {
        addSubHeader('ç¬¬ä¸€æ¬¡èŠå¤©å ´æ™¯');
        addLine(limitText(fields.firstScene, 800));
      }

      if (fields.sampleDialogue) {
        addSubHeader('è§’è‰²å°è©±');
        addLine(limitText(fields.sampleDialogue, 800));
      }

      // --- Favs ---
      if (fields.likes || fields.dislikes) {
        addSubHeader('å–œå¥½');
        if (fields.likes) addProp('å–œæ­¡', limitText(fields.likes, 50));
        if (fields.dislikes) addProp('ä¸å–œæ­¡', limitText(fields.dislikes, 50));
      }

      // --- Extras ---
      addMainHeader('é™„åŠ è³‡è¨Š');
      if (!extras || extras.length === 0) {
        addLine("- ï¼ˆå°šæœªå¡«å¯«ï¼‰");
      } else {
        extras.forEach((item, idx) => {
          if (!item.title && !item.text) return;
          addSubSubHeader(`é™„åŠ è³‡è¨Š ${idx + 1}`);
          if (item.title) addProp('æ¨™é¡Œ', limitText(item.title, 50));
          if (item.text) addLine(limitText(item.text, 500));
        });
      }

      // --- Events ---
      addMainHeader('å‰µä½œè€…äº‹ä»¶');
      if (!events || events.length === 0) {
        addLine("- ï¼ˆå°šæœªå¡«å¯«ï¼‰");
      } else {
        events.forEach((item, idx) => {
          if (!item.title && !item.text) return;
          addSubSubHeader(`å‰µä½œè€…äº‹ä»¶ ${idx + 1}`);
          if (item.title) addProp('æ¨™é¡Œ', limitText(item.title, 50));
          if (item.text) addLine(limitText(item.text, 2000));
        });
      }

      return lines.join('\n');
    };

    const parseMarkdown = (md) => {
      // Minimal Parser for restore functionality
      // Note: This is a best-effort parser given the loose structure of MD
      const lines = md.split(/\r?\n/);
      const data = {
        fields: { ...DEFAULT_FIELDS },
        extras: [],
        events: [],
        gameManagement: { ...DEFAULT_GAME_MANAGEMENT, stories: [] }
      };

      const readBlock = (startIndex) => {
        let i = startIndex;
        const buf = [];
        while (i < lines.length) {
          const t = lines[i];
          const trimmed = t.trim();
          if (trimmed.startsWith("#") || trimmed.startsWith("##") || trimmed.startsWith("###")) break;
          buf.push(t);
          i++;
        }
        while (buf.length && buf[buf.length - 1].trim() === "") buf.pop();
        return { text: buf.join("\n").trim(), nextIndex: i - 1 };
      };

      let currentSection = '';

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith('# ')) currentSection = line;

        if (line.startsWith("- åç¨±ï¼š")) data.fields.charName = line.replace("- åç¨±ï¼š", "").replace("ï¼ˆæœªå‘½åï¼‰", "").trim();
        else if (line.startsWith("- åˆ†é¡ï¼š")) data.fields.charCategory = line.replace("- åˆ†é¡ï¼š", "").trim();
        else if (line.startsWith("- æ€§åˆ¥ï¼š")) data.fields.gender = line.replace("- æ€§åˆ¥ï¼š", "").trim();
        else if (line.startsWith("- å¹´é½¡ï¼š")) data.fields.charAge = line.replace("- å¹´é½¡ï¼š", "").trim();
        else if (line.startsWith("- è·æ¥­ï¼š")) data.fields.charJob = line.replace("- è·æ¥­ï¼š", "").trim();
        else if (line.startsWith("- ç”Ÿæ—¥ï¼š")) data.fields.birthday = line.replace("- ç”Ÿæ—¥ï¼š", "").trim();
        else if (line.startsWith("- æ¨™ç±¤ï¼š")) data.fields.charTags = line.replace("- æ¨™ç±¤ï¼š", "").trim().replace(/#/g, '').split(/\s+/).join(", ");
        else if (line.startsWith("- å–œæ­¡ï¼š")) data.fields.likes = line.replace("- å–œæ­¡ï¼š", "").trim();
        else if (line.startsWith("- ä¸å–œæ­¡ï¼š")) data.fields.dislikes = line.replace("- ä¸å–œæ­¡ï¼š", "").trim();
        
        else if (line === "## æ•˜è¿°") {
           const res = readBlock(i + 1);
           data.fields.charDesc = res.text;
           i = res.nextIndex;
        }
        else if (line === "## å‰µä½œè€…ç­†è¨˜") {
           const res = readBlock(i + 1);
           data.fields.creatorNote = res.text;
           i = res.nextIndex;
        }
        else if (line === "## åŸºæœ¬è³‡è¨Š") {
            const res = readBlock(i + 1);
            data.fields.basicInfo = res.text === "ï¼ˆå°šæœªå¡«å¯«ï¼‰" ? "" : res.text;
            i = res.nextIndex;
        }
        else if (line === "## æ€§æ ¼") {
            const res = readBlock(i + 1);
            data.fields.personality = res.text === "ï¼ˆå°šæœªå¡«å¯«ï¼‰" ? "" : res.text;
            i = res.nextIndex;
        }
        else if (line === "## èªªè©±é¢¨æ ¼èˆ‡ç¿’æ…£") {
            const res = readBlock(i + 1);
            data.fields.speechStyle = res.text === "ï¼ˆå°šæœªå¡«å¯«ï¼‰" ? "" : res.text;
            i = res.nextIndex;
        }
        else if (line === "## ç¬¬ä¸€æ¬¡èŠå¤©å ´æ™¯") {
            const res = readBlock(i + 1);
            data.fields.firstScene = res.text;
            i = res.nextIndex;
        }
        else if (line === "## è§’è‰²å°è©±") {
            const res = readBlock(i + 1);
            data.fields.sampleDialogue = res.text;
            i = res.nextIndex;
        }
        // Parsing Extras/Events
        else if (line.startsWith("### é™„åŠ è³‡è¨Š")) {
            const res = readBlock(i + 1);
            if (res.text && res.text !== "ï¼ˆå°šæœªå¡«å¯«ï¼‰") {
                let title = "";
                let body = res.text;
                const parts = res.text.split(/\r?\n/);
                if (parts.length > 0 && parts[0].trim().startsWith("- æ¨™é¡Œï¼š")) {
                     title = parts[0].trim().replace("- æ¨™é¡Œï¼š", "").trim();
                     body = parts.slice(1).join("\n").trim();
                }
                data.extras.push({ title, text: body });
            }
            i = res.nextIndex;
        }
        else if (line.startsWith("### å‰µä½œè€…äº‹ä»¶")) {
            const res = readBlock(i + 1);
            if (res.text && res.text !== "ï¼ˆå°šæœªå¡«å¯«ï¼‰") {
                let title = "";
                let body = res.text;
                const parts = res.text.split(/\r?\n/);
                if (parts.length > 0 && parts[0].trim().startsWith("- æ¨™é¡Œï¼š")) {
                     title = parts[0].trim().replace("- æ¨™é¡Œï¼š", "").trim();
                     body = parts.slice(1).join("\n").trim();
                }
                data.events.push({ title, text: body });
            }
            i = res.nextIndex;
        }
        // Basic Game Management Parsing
        else if (line.startsWith("- éŠæˆ²æ¨™é¡Œï¼š")) {
             data.gameManagement.info.title = line.replace("- éŠæˆ²æ¨™é¡Œï¼š", "").trim();
        }
      }
      return data;
    };

    // --- Components ---

    const ToastContext = createContext(undefined);
    
    const ToastProvider = ({ children }) => {
      const [toasts, setToasts] = useState([]);
      const showToast = useCallback((message, type = 'info') => {
        const id = Date.now();
        setToasts((prev) => [...prev, { id, message, type }]);
        setTimeout(() => { setToasts((prev) => prev.filter((t) => t.id !== id)); }, 3000);
      }, []);

      return (
        <ToastContext.Provider value={{ showToast }}>
          {children}
          <div className="fixed bottom-8 left-1/2 transform -translate-x-1/2 z-[9999] flex flex-col gap-2 pointer-events-none">
            {toasts.map((toast) => (
              <div key={toast.id} className="bg-gray-800/90 text-white px-6 py-3 rounded-full shadow-xl backdrop-blur-md flex items-center gap-3 animate-in fade-in slide-in-from-bottom-4">
                <span>{toast.type === 'success' || toast.type === 'info' ? 'âœ…' : toast.type === 'warn' ? 'âš ï¸' : 'âŒ'}</span>
                <span className="font-medium">{toast.message}</span>
              </div>
            ))}
          </div>
        </ToastContext.Provider>
      );
    };

    const useToast = () => {
       const ctx = useContext(ToastContext);
       if(!ctx) throw new Error("Missing ToastProvider");
       return ctx;
    };

    const ThemeWrapper = ({ theme, children }) => {
      return (
        <div style={THEMES[theme]} className="min-h-screen bg-page-bg text-text-main transition-colors duration-500 font-sans">
          <div className="fixed inset-0 pointer-events-none opacity-50 bg-[url('https://www.transparenttextures.com/patterns/stardust.png')] z-0" />
          <div className="relative z-10">{children}</div>
        </div>
      );
    };

    const Sidebar = ({ onNavigate, isMobile }) => {
      const [collapsed, setCollapsed] = useState(false);
      const menuItems = [
        { id: 'sec-archive', icon: 'ğŸ“‚', label: 'è§’è‰²å­˜æª”', main: true },
        { id: 'sec-info', icon: 'ğŸ’â€â™€ï¸', label: 'è§’è‰²è³‡è¨Š' },
        { id: 'sec-game-mgr', icon: 'ğŸ®', label: 'éŠæˆ²ç®¡ç†', main: true },
        { id: 'sec-gender', icon: 'ğŸš»', label: 'æ€§åˆ¥è¨­å®š' },
        { id: 'sec-basic', icon: 'ğŸŒ', label: 'åŸºæœ¬è³‡è¨Š' },
        { id: 'sec-personality', icon: 'ğŸ’—', label: 'æ€§æ ¼ç‰¹è³ª' },
        { id: 'sec-speech', icon: 'ğŸ—£ï¸', label: 'èªªè©±é¢¨æ ¼' },
        { id: 'sec-prompt', icon: 'ğŸ§ ', label: 'Prompt è¨­å®š' },
        { id: 'sec-first', icon: 'ğŸ¬', label: 'é–‹å ´èˆ‡å°è©±' },
        { id: 'sec-fav', icon: 'ğŸ€', label: 'å–œå¥½ç”Ÿæ—¥' },
        { id: 'sec-extra', icon: 'ğŸ“Œ', label: 'é™„åŠ è³‡è¨Š' },
        { id: 'sec-event', icon: 'ğŸ“š', label: 'å‰µä½œè€…äº‹ä»¶' },
        { id: 'sec-output', icon: 'ğŸ“', label: 'è¼¸å‡º/é è¦½', main: true },
        { id: 'sec-template-center', icon: 'ğŸ§°', label: 'æ¨¡æ¿ç®¡ç†', main: true },
      ];

      if (isMobile) {
        return (
          <div className="sticky top-2 z-50 bg-white/80 dark:bg-gray-800/80 backdrop-blur-md p-2 rounded-xl shadow-lg overflow-x-auto flex gap-2 no-scrollbar mb-4 border border-border-color">
            {menuItems.map((item) => (
              <button key={item.id} onClick={() => onNavigate(item.id)} className="flex-shrink-0 whitespace-nowrap px-4 py-2 rounded-full bg-white/50 border border-border-color text-sm font-medium hover:bg-focus hover:text-white transition-colors">
                <span className="mr-2">{item.icon}</span>{item.label}
              </button>
            ))}
          </div>
        );
      }

      return (
        <aside className={`sticky top-6 bg-sidebar-bg backdrop-blur-xl p-5 rounded-3xl shadow-lg border border-white/50 transition-all duration-300 z-40 ${collapsed ? 'w-20' : 'w-64'}`}>
          <div className={`flex items-center justify-between mb-6 pb-3 border-b border-border-color ${collapsed ? 'justify-center' : ''}`}>
            {!collapsed && <div className="font-bold text-lg text-text-main tracking-wide">ğŸ“ åŠŸèƒ½å°èˆª</div>}
            <button onClick={() => setCollapsed(!collapsed)} className="w-8 h-8 flex items-center justify-center rounded-full border border-border-color text-text-sub hover:bg-focus hover:text-white hover:border-focus transition-all">
              {collapsed ? 'â–¶' : 'â—€'}
            </button>
          </div>
          {!collapsed && <div className="text-xs text-text-sub mb-4">é»æ“Šå¿«é€Ÿè·³è½‰</div>}
          <nav className="flex flex-col gap-2">
            {menuItems.map((item) => (
              <button key={item.id} onClick={() => onNavigate(item.id)} className={`flex items-center text-left transition-all duration-200 rounded-xl ${collapsed ? 'justify-center py-3 px-0' : 'px-4 py-3'} ${item.main ? 'font-bold' : 'text-sm text-text-main hover:translate-x-1'} hover:bg-black/5 dark:hover:bg-white/10 hover:text-focus`}>
                <span className={`${collapsed ? 'text-xl' : 'mr-3 text-lg'}`}>{item.icon}</span>
                {!collapsed && <span>{item.label}</span>}
              </button>
            ))}
          </nav>
        </aside>
      );
    };

    const Section = ({ id, title, icon, children }) => {
      const [collapsed, setCollapsed] = useState(false);
      return (
        <div id={id} className={`bg-card-bg backdrop-blur-xl rounded-3xl p-8 mb-8 shadow-sm border border-white/60 transition-all duration-300 hover:shadow-md ${collapsed ? 'pb-5 opacity-80' : ''}`}>
          <div className="flex items-center justify-between border-b border-border-color pb-3 mb-6">
            <h2 className="text-xl font-serif font-bold flex items-center gap-2 text-text-main">
              <span>{icon}</span><span>{title}</span>
            </h2>
            <button onClick={() => setCollapsed(!collapsed)} className="p-2 text-sm border border-border-color rounded-lg hover:bg-focus hover:text-white transition-colors">â‡•</button>
          </div>
          <div className={`transition-all duration-500 overflow-hidden ${collapsed ? 'max-h-0 opacity-0' : 'max-h-[5000px] opacity-100'}`}>
            {children}
          </div>
        </div>
      );
    };

    const InputRow = ({ label, value, onChange, placeholder, type = 'text', maxLength, onClear, actions }) => (
      <div className="mb-4">
        {(label || onClear || actions) && (
          <div className="flex justify-between items-end mb-2">
            {label && <label className="font-semibold text-text-main text-sm tracking-wide">{label}</label>}
            <div className="flex gap-2">
              {actions}
              {onClear && <button onClick={onClear} className="text-xs px-3 py-1 rounded-lg border border-border-color hover:bg-focus hover:text-white transition-colors">æ¸…ç©º</button>}
            </div>
          </div>
        )}
        <input type={type} value={value} onChange={(e) => onChange(e.target.value)} placeholder={placeholder} className="w-full px-4 py-3 bg-white/50 dark:bg-black/20 border border-border-color rounded-xl focus:outline-none focus:ring-2 focus:ring-focus focus:bg-white dark:focus:bg-black/40 transition-all" maxLength={maxLength} />
        {maxLength && <div className="text-right text-xs text-text-sub mt-1">{value.length} / {maxLength}</div>}
      </div>
    );

    const TextAreaRow = ({ label, subLabel, value, onChange, placeholder, maxLength, onClear, actions, minHeight = '120px' }) => {
      const { showToast } = useToast();
      return (
        <div className="mb-6">
          {(label || onClear || actions) && (
            <div className="flex justify-between items-end mb-2 flex-wrap gap-2">
              <div>
                {label && <label className="font-semibold text-text-main text-lg tracking-wide block">{label}</label>}
                {subLabel && <span className="text-xs text-text-sub">{subLabel}</span>}
              </div>
              <div className="flex gap-2 items-center">
                {actions}
                <button onClick={() => { navigator.clipboard.writeText(value).then(() => showToast('å·²è¤‡è£½å…§å®¹ï¼')); }} className="text-xs px-3 py-1 rounded-lg border border-border-color hover:bg-focus hover:text-white transition-colors">è¤‡è£½</button>
                {onClear && <button onClick={onClear} className="text-xs px-3 py-1 rounded-lg border border-border-color hover:bg-focus hover:text-white transition-colors">æ¸…ç©º</button>}
              </div>
            </div>
          )}
          <textarea value={value} onChange={(e) => onChange(e.target.value)} placeholder={placeholder} className="w-full px-4 py-3 bg-white/50 dark:bg-black/20 border border-border-color rounded-xl focus:outline-none focus:ring-2 focus:ring-focus focus:bg-white dark:focus:bg-black/40 transition-all resize-y" style={{ minHeight }} maxLength={maxLength} />
          <div className="flex justify-end mt-1">
            <span className={`text-xs ${maxLength && value.length >= maxLength ? 'text-red-500' : 'text-text-sub'}`}>
              {value.length} {maxLength ? `/ ${maxLength}` : 'å­—'}
            </span>
          </div>
        </div>
      );
    };

    const GameManagement = ({ data, onChange }) => {
      const updateInfo = (key, val) => onChange({ ...data, info: { ...data.info, [key]: val } });
      const addStory = () => {
        const newStory = { id: `story_${Date.now()}`, title: '', unlockHint: '', content: '', stage: 'acquaintance', affinityScore: 0, rating: 'all', access: 'free', hasEndings: false, endings: [] };
        onChange({ ...data, stories: [...data.stories, newStory] });
      };
      const updateStory = (index, field, val) => {
        const newStories = [...data.stories];
        newStories[index] = { ...newStories[index], [field]: val };
        onChange({ ...data, stories: newStories });
      };
      const removeStory = (index) => {
        const newStories = [...data.stories];
        newStories.splice(index, 1);
        onChange({ ...data, stories: newStories });
      };
      const addEnding = (sIdx) => {
        const newStories = [...data.stories];
        newStories[sIdx].endings.push({ option: '', content: '', affinity: 0 });
        onChange({ ...data, stories: newStories });
      };
      const updateEnding = (sIdx, eIdx, field, val) => {
        const newStories = [...data.stories];
        newStories[sIdx].endings[eIdx] = { ...newStories[sIdx].endings[eIdx], [field]: val };
        onChange({ ...data, stories: newStories });
      };
      const removeEnding = (sIdx, eIdx) => {
        const newStories = [...data.stories];
        newStories[sIdx].endings.splice(eIdx, 1);
        onChange({ ...data, stories: newStories });
      };

      return (
        <Section id="sec-game-mgr" title="éŠæˆ²ç®¡ç†" icon="ğŸ®">
          <div className="mb-8 border-b border-border-color pb-6">
            <h3 className="font-bold text-lg mb-4 text-text-main">1. éŠæˆ²ä»‹ç´¹åŸºæœ¬è³‡è¨Š</h3>
            <div className="flex flex-col md:flex-row gap-4">
              <div className="flex-1"><InputRow label="éŠæˆ²æ¨™é¡Œ (30å­—)" value={data.info.title} onChange={v => updateInfo('title', v)} maxLength={30} /></div>
              <div className="flex-1"><InputRow label="éŠæˆ²ä»‹ç´¹ (30å­—)" value={data.info.intro} onChange={v => updateInfo('intro', v)} maxLength={30} /></div>
            </div>
          </div>
          <div>
            <h3 className="font-bold text-lg mb-4 text-text-main flex justify-between items-center">
              <span>2. ç§å¯†ç‰©èª (ç§å¯†åŠ‡æƒ…)</span>
              <button onClick={addStory} className="text-xs bg-focus text-white px-3 py-1 rounded-full hover:opacity-90">ï¼‹ æ–°å¢ç‰©èª</button>
            </h3>
            <div className="flex flex-col gap-6">
              {data.stories.map((story, sIdx) => (
                <div key={story.id} className="bg-white/40 dark:bg-black/20 rounded-2xl p-5 border border-border-color relative">
                  <button onClick={() => removeStory(sIdx)} className="absolute top-4 right-4 text-xs text-red-500 border border-red-200 px-2 py-1 rounded hover:bg-red-50">åˆªé™¤æ­¤ç‰©èª</button>
                  
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4 pr-20">
                    <div>
                      <label className="text-xs font-bold text-text-sub block mb-1">éšæ®µ</label>
                      <select value={story.stage} onChange={e => updateStory(sIdx, 'stage', e.target.value)} className="w-full text-sm p-2 rounded-lg border border-border-color bg-white/60">
                        {Object.entries(STAGE_LABELS).map(([k, v]) => <option key={k} value={k}>{v}</option>)}
                      </select>
                    </div>
                    <div>
                      <label className="text-xs font-bold text-text-sub block mb-1">å¥½æ„Ÿåº¦åˆ†æ•¸</label>
                      <input type="number" value={story.affinityScore} onChange={e => updateStory(sIdx, 'affinityScore', parseInt(e.target.value) || 0)} className="w-full text-sm p-2 rounded-lg border border-border-color bg-white/60" />
                    </div>
                    <div>
                      <label className="text-xs font-bold text-text-sub block mb-1">åˆ†ç´š</label>
                      <select value={story.rating} onChange={e => updateStory(sIdx, 'rating', e.target.value)} className="w-full text-sm p-2 rounded-lg border border-border-color bg-white/60">
                        <option value="all">æ‰€æœ‰å¹´é½¡</option>
                        <option value="adult">æˆäººé™å®š</option>
                      </select>
                    </div>
                    <div>
                       <label className="text-xs font-bold text-text-sub block mb-1">å…¬é–‹è¨­å®š</label>
                       <select value={story.access} onChange={e => updateStory(sIdx, 'access', e.target.value)} className="w-full text-sm p-2 rounded-lg border border-border-color bg-white/60">
                         <option value="free">å…è²»</option>
                         <option value="paid">ä»˜è²» (10æœé†¬)</option>
                       </select>
                    </div>
                  </div>
                  
                  <div className="flex gap-4 mb-2">
                    <div className="flex-[2]"><InputRow label="æ•…äº‹æ¨™é¡Œ (30å­—)" value={story.title} onChange={v => updateStory(sIdx, 'title', v)} maxLength={30} /></div>
                    <div className="flex-[3]"><InputRow label="è§£é–æç¤ºèª (60å­—)" value={story.unlockHint} onChange={v => updateStory(sIdx, 'unlockHint', v)} maxLength={60} /></div>
                  </div>
                  <TextAreaRow label="æ•…äº‹å…§å®¹ (2000å­—)" value={story.content} onChange={v => updateStory(sIdx, 'content', v)} maxLength={2000} minHeight="150px" />
                  
                  <div className="mt-4">
                    <label className="flex items-center gap-2 cursor-pointer">
                      <input type="checkbox" checked={story.hasEndings} onChange={e => updateStory(sIdx, 'hasEndings', e.target.checked)} className="w-4 h-4" />
                      <span className="font-bold text-sm text-text-main">å•Ÿç”¨å¤šé‡çµå±€</span>
                    </label>
                  </div>
                  
                  {story.hasEndings && (
                    <div className="mt-4 pl-4 border-l-2 border-focus bg-focus/5 p-4 rounded-r-xl">
                      <h4 className="text-sm font-bold mb-3 text-focus">å¤šé‡çµå±€é¸é …è¨­å®š</h4>
                      {story.endings.map((ending, eIdx) => (
                        <div key={eIdx} className="mb-4 bg-white/80 p-3 rounded-lg border border-border-color">
                          <div className="flex justify-between items-start mb-2">
                             <span className="text-xs font-bold bg-gray-200 px-2 py-1 rounded text-gray-600">é¸é … {eIdx + 1}</span>
                             <button onClick={() => removeEnding(sIdx, eIdx)} className="text-xs text-red-400 hover:text-red-600">ç§»é™¤</button>
                          </div>
                          <InputRow placeholder="é¸é …æ–‡å­— (ä¾‹å¦‚ï¼šæº«æŸ”åœ°æŠ±ä½ä»–) - 100å­—" value={ending.option} onChange={v => updateEnding(sIdx, eIdx, 'option', v)} maxLength={100} />
                          <div className="flex gap-4 items-start">
                             <div className="flex-1"><TextAreaRow placeholder="é¸æ“‡å¾Œé¡¯ç¤ºçš„å…§å®¹ - 500å­—" value={ending.content} onChange={v => updateEnding(sIdx, eIdx, 'content', v)} maxLength={500} minHeight="80px" /></div>
                             <div className="w-24">
                                <label className="text-xs block mb-1 text-text-sub">å¥½æ„Ÿåº¦å¢æ¸›</label>
                                <input type="number" min="-20" max="20" value={ending.affinity} onChange={e => updateEnding(sIdx, eIdx, 'affinity', parseInt(e.target.value) || 0)} className="w-full p-2 text-sm border border-border-color rounded-lg text-center" />
                                <div className="text-[10px] text-center text-gray-400 mt-1">-20 ~ +20</div>
                             </div>
                          </div>
                        </div>
                      ))}
                      <button onClick={() => addEnding(sIdx)} className="w-full py-2 text-sm border border-dashed border-focus text-focus rounded-lg hover:bg-focus hover:text-white transition-colors">ï¼‹ æ–°å¢é¸é …</button>
                    </div>
                  )}
                </div>
              ))}
              {data.stories.length === 0 && <div className="text-center text-text-sub py-4">å°šæœªæ–°å¢ä»»ä½•ç§å¯†ç‰©èª</div>}
            </div>
          </div>
        </Section>
      );
    };

    const InnerApp = () => {
      const { showToast } = useToast();
      const [isMobile, setIsMobile] = useState(window.innerWidth <= 850);
      const [theme, setTheme] = useState('pink');
      const [store, setStore] = useState({ currentId: null, chars: {}, templates: { basicInfo: [], personality: [], speechStyle: [], extra: [], event: [] } });
      const [formData, setFormData] = useState({ fields: { ...DEFAULT_FIELDS }, extras: [], events: [], gameManagement: { ...DEFAULT_GAME_MANAGEMENT } });

      const STORAGE_KEY = 'qing_char_standalone_v1';

      useEffect(() => {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          try {
            const parsed = JSON.parse(raw);
            if (!parsed.templates) parsed.templates = { basicInfo: [], personality: [], speechStyle: [], extra: [], event: [] };
            if (!parsed.chars) parsed.chars = {};
            // Migration
            Object.keys(parsed.chars).forEach(key => {
               if(!parsed.chars[key].data.gameManagement) {
                   parsed.chars[key].data.gameManagement = { ...DEFAULT_GAME_MANAGEMENT };
               }
            });
            setStore(parsed);
            if (parsed.currentId && parsed.chars[parsed.currentId]) {
              setFormData(parsed.chars[parsed.currentId].data);
            }
          } catch (e) {}
        }
      }, []);

      useEffect(() => { localStorage.setItem(STORAGE_KEY, JSON.stringify(store)); }, [store]);
      useEffect(() => {
        const handleResize = () => setIsMobile(window.innerWidth <= 850);
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);

      const scrollToSection = (id) => {
        const el = document.getElementById(id);
        if (el) {
          const yOffset = -80;
          const y = el.getBoundingClientRect().top + window.pageYOffset + yOffset;
          window.scrollTo({ top: y, behavior: 'smooth' });
        }
      };

      const updateField = (key, value) => {
        const newData = { ...formData, fields: { ...formData.fields, [key]: value } };
        setFormData(newData);
        saveToStore(newData);
      };

      const saveToStore = (data) => {
        if (!store.currentId) return;
        setStore(prev => ({
          ...prev,
          chars: {
            ...prev.chars,
            [prev.currentId]: {
              meta: {
                name: data.fields.charName || 'æœªå‘½åè§’è‰²',
                category: data.fields.charCategory || '',
                tags: data.fields.charTags.split(/[,ï¼Œ\s]+/).filter(Boolean),
                createdAt: prev.chars[prev.currentId]?.meta.createdAt || Date.now()
              },
              data: data
            }
          }
        }));
      };

      const createNewChar = () => {
        const newId = `char_${Date.now()}`;
        const newChar = {
          meta: { name: 'æœªå‘½åè§’è‰²', category: '', tags: [], createdAt: Date.now() },
          data: { fields: { ...DEFAULT_FIELDS }, extras: [], events: [], gameManagement: { ...DEFAULT_GAME_MANAGEMENT } }
        };
        setStore(prev => ({ ...prev, currentId: newId, chars: { ...prev.chars, [newId]: newChar } }));
        setFormData(newChar.data);
        showToast('å·²å»ºç«‹æ–°è§’è‰²');
        window.scrollTo({ top: 0, behavior: 'smooth' });
      };
      
      const deleteChar = () => {
        if (!store.currentId) return;
        if (!confirm("ç¢ºå®šè¦åˆªé™¤é€™å€‹è§’è‰²å—ï¼Ÿ")) return;
        setStore(prev => {
          const newChars = { ...prev.chars };
          delete newChars[prev.currentId];
          const remainingIds = Object.keys(newChars);
          const nextId = remainingIds.length > 0 ? remainingIds[0] : null;
          if (nextId) setFormData(newChars[nextId].data);
          else setFormData({ fields: { ...DEFAULT_FIELDS }, extras: [], events: [], gameManagement: { ...DEFAULT_GAME_MANAGEMENT } });
          return { ...prev, currentId: nextId, chars: newChars };
        });
        showToast('è§’è‰²å·²åˆªé™¤', 'warn');
      };

      const loadChar = (id) => {
        setStore(prev => ({ ...prev, currentId: id }));
        setFormData(store.chars[id].data);
        showToast(`å·²è¼‰å…¥: ${store.chars[id].meta.name}`);
      };

      const addDynamicField = (type) => {
        if (formData[type].length >= (type === 'extras' ? 10 : 20)) { showToast('å·²é”æ•¸é‡ä¸Šé™', 'warn'); return; }
        const newData = { ...formData, [type]: [...formData[type], { title: '', text: '' }] };
        setFormData(newData);
        saveToStore(newData);
      };

      const updateDynamicField = (type, index, key, val) => {
        const list = [...formData[type]];
        list[index] = { ...list[index], [key]: val };
        const newData = { ...formData, [type]: list };
        setFormData(newData);
        saveToStore(newData);
      };

      const removeDynamicField = (type, index) => {
        const list = [...formData[type]];
        list.splice(index, 1);
        const newData = { ...formData, [type]: list };
        setFormData(newData);
        saveToStore(newData);
      };

      const updateGameManagement = (gmData) => {
        const newData = { ...formData, gameManagement: gmData };
        setFormData(newData);
        saveToStore(newData);
      };

      const saveTemplate = (type, text) => {
        if (!text.trim()) { showToast('å…§å®¹ç‚ºç©º', 'warn'); return; }
        const name = prompt('è«‹è¼¸å…¥æ¨¡æ¿åç¨±ï¼š');
        if (!name) return;
        setStore(prev => ({
          ...prev,
          templates: {
            ...prev.templates,
            [type]: [...(prev.templates[type] || []), { id: `tpl_${Date.now()}`, name, text }]
          }
        }));
        showToast('æ¨¡æ¿å·²å„²å­˜');
      };
      const deleteTemplate = (type, id) => {
          setStore(prev => ({ ...prev, templates: { ...prev.templates, [type]: prev.templates[type].filter(t => t.id !== id) } }));
          showToast('æ¨¡æ¿å·²åˆªé™¤');
      };
      
      const TemplateSelector = ({ type, onApply, currentValue }) => (
        <div className="flex gap-2">
          <select className="text-xs px-2 py-1 rounded-lg border border-border-color bg-white/50" onChange={(e) => { const tpl = store.templates[type].find(t => t.id === e.target.value); if (tpl) onApply(tpl.text); e.target.value = ''; }} defaultValue="">
            <option value="" disabled>âœ¨ å¥—ç”¨æ¨¡æ¿...</option>
            {(store.templates[type] || []).map(t => <option key={t.id} value={t.id}>{t.name}</option>)}
          </select>
          <button className="text-xs px-2 py-1 rounded-lg border border-border-color hover:bg-focus hover:text-white" onClick={() => saveTemplate(type, currentValue)}>å­˜ç‚ºæ¨¡æ¿</button>
        </div>
      );

      const exportMD = () => {
        const md = generateMarkdown(formData);
        const blob = new Blob([md], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${formData.fields.charName || 'character'}.txt`;
        a.click();
      };

      const promptTokens = estimatePromptTokens(formData.fields.promptRole, formData.fields.promptGuideline);

      return (
        <ThemeWrapper theme={theme}>
          <div className="max-w-6xl mx-auto p-5 min-h-screen flex flex-col">
            <div className="flex flex-wrap justify-between items-end gap-4 mb-8">
              <div>
                <h1 className="text-4xl font-bold font-serif text-text-main mb-2 tracking-tight">ğŸ’• å¿å¿æˆ‘æˆ‘å‰µè§’å°å¹«æ‰‹</h1>
                <p className="text-text-sub">å¡«å¯«è¨­å®šï¼Œä¸€éµç”Ÿæˆ AI è§’è‰²å¡ Markdownï¼Œè®“æ•…äº‹é–‹å§‹ã€‚</p>
              </div>
              <div className="flex items-center gap-3 bg-card-bg p-2 rounded-xl border border-white/50 shadow-sm">
                <span className="text-sm font-semibold ml-2">ğŸ¨ ä¸»é¡Œï¼š</span>
                <select value={theme} onChange={(e) => setTheme(e.target.value)} className="bg-transparent border-none text-sm font-medium focus:ring-0 cursor-pointer">
                  {Object.keys(THEMES).map(t => <option key={t} value={t}>{t === 'pink' ? 'ğŸŒ¸ æ«»èŠ±ç²‰' : t === 'black' ? 'ğŸŒ™ æ·±å¤œé»‘' : t}</option>)}
                </select>
              </div>
            </div>

            <div className="flex flex-col md:flex-row gap-8 items-start">
              <Sidebar onNavigate={scrollToSection} isMobile={isMobile} />
              <main className="flex-1 w-full min-w-0">
                <Section id="sec-archive" title="è§’è‰²å­˜æª”ç®¡ç†" icon="ğŸ“‚">
                  <div className="flex flex-col gap-4">
                    <div className="flex flex-wrap gap-2 p-3 bg-white/40 rounded-xl border border-border-color min-h-[50px] items-center">
                       {Object.entries(store.chars).map(([id, char]) => (
                           <button key={id} onClick={() => loadChar(id)} className={`px-3 py-1.5 rounded-lg text-sm transition-all ${store.currentId === id ? 'bg-focus text-white shadow-md scale-105 font-bold' : 'bg-white/60 border border-border-color hover:bg-white'}`}>{char.meta.name || 'æœªå‘½å'}</button>
                       ))}
                    </div>
                    <div className="flex gap-3 mt-2">
                        <button onClick={createNewChar} className="bg-btn-bg text-btn-text px-4 py-2 rounded-full font-bold shadow-lg hover:scale-105 transition-transform">â• æ–°è§’è‰²</button>
                        <button onClick={deleteChar} className="bg-transparent border border-red-400 text-red-500 hover:bg-red-50 px-4 py-2 rounded-full font-bold transition-colors ml-auto">ğŸ—‘ åˆªé™¤ç›®å‰</button>
                    </div>
                  </div>
                </Section>

                <Section id="sec-info" title="è§’è‰²è³‡è¨Š" icon="ğŸ’â€â™€ï¸">
                  <InputRow label="è§’è‰²åç¨± (15å­—)" value={formData.fields.charName} onChange={v => updateField('charName', v)} onClear={() => updateField('charName', '')} maxLength={15} />
                  <InputRow label="è§’è‰²åˆ†é¡" value={formData.fields.charCategory} onChange={v => updateField('charCategory', v)} placeholder="ä¾‹å¦‚ï¼šç¾ä»£ã€å¥‡å¹»ã€OC..." maxLength={100} />
                  <div className="flex gap-4">
                      <div className="flex-1"><InputRow label="å¹´é½¡ (15å­—)" value={formData.fields.charAge} onChange={v => updateField('charAge', v)} maxLength={15} /></div>
                      <div className="flex-1"><InputRow label="è·æ¥­ (15å­—)" value={formData.fields.charJob} onChange={v => updateField('charJob', v)} maxLength={15} /></div>
                  </div>
                  <TextAreaRow label="ä¾†è‡ªè§’è‰²çš„ä¸€å¥è©± (80å­—)" value={formData.fields.charQuote} onChange={v => updateField('charQuote', v)} minHeight="80px" maxLength={80} onClear={() => updateField('charQuote', '')} />
                  <TextAreaRow label="æ•˜è¿° (700å­—)" value={formData.fields.charDesc} onChange={v => updateField('charDesc', v)} maxLength={700} onClear={() => updateField('charDesc', '')} />
                  <InputRow label="æ¨™ç±¤ (Hashtag)" value={formData.fields.charTags} onChange={v => updateField('charTags', v)} placeholder="ç©ºæ ¼åˆ†éš”ï¼Œå¦‚ï¼šå‚²å¬Œ é›™é¦¬å°¾" />
                  <TextAreaRow label="å‰µä½œè€…ç­†è¨˜ (200å­—)" value={formData.fields.creatorNote} onChange={v => updateField('creatorNote', v)} minHeight="80px" maxLength={200} onClear={() => updateField('creatorNote', '')} />
                </Section>

                <Section id="sec-gender" title="æ€§åˆ¥" icon="ğŸš»">
                   <select value={formData.fields.gender} onChange={e => updateField('gender', e.target.value)} className="w-full px-4 py-3 bg-white/50 border border-border-color rounded-xl">
                      <option value="æœªè¨­ç½®">æœªè¨­ç½®</option>
                      <option value="ç”·æ€§">ç”·æ€§</option>
                      <option value="å¥³æ€§">å¥³æ€§</option>
                      <option value="ç„¡æ€§åˆ¥">ç„¡æ€§åˆ¥</option>
                   </select>
                </Section>

                <Section id="sec-basic" title="ä¸€ã€åŸºæœ¬è³‡è¨Š" icon="ğŸŒ">
                    <TextAreaRow subLabel="å¿…å¡«ã€‚å»ºè­° â‰¤700å­—ã€‚" value={formData.fields.basicInfo} onChange={v => updateField('basicInfo', v)} maxLength={700} onClear={() => updateField('basicInfo', '')} actions={<TemplateSelector type="basicInfo" currentValue={formData.fields.basicInfo} onApply={v => updateField('basicInfo', v)} />} />
                </Section>
                <Section id="sec-personality" title="äºŒã€æ€§æ ¼" icon="ğŸ’—">
                    <TextAreaRow subLabel="å¿…å¡«ã€‚å»ºè­° â‰¤700å­—ã€‚" value={formData.fields.personality} onChange={v => updateField('personality', v)} maxLength={700} onClear={() => updateField('personality', '')} actions={<TemplateSelector type="personality" currentValue={formData.fields.personality} onApply={v => updateField('personality', v)} />} />
                </Section>
                <Section id="sec-speech" title="ä¸‰ã€èªªè©±é¢¨æ ¼èˆ‡ç¿’æ…£" icon="ğŸ—£ï¸">
                    <TextAreaRow subLabel="å¿…å¡«ã€‚å»ºè­° â‰¤700å­—ã€‚" value={formData.fields.speechStyle} onChange={v => updateField('speechStyle', v)} maxLength={700} onClear={() => updateField('speechStyle', '')} actions={<TemplateSelector type="speechStyle" currentValue={formData.fields.speechStyle} onApply={v => updateField('speechStyle', v)} />} />
                </Section>

                <Section id="sec-prompt" title="æ¨¡å‹èˆ‡ Prompt è¨­å®š" icon="ğŸ§ ">
                    <div className="mb-4">
                       <label className="font-semibold block mb-2">ä½¿ç”¨æ¨¡å‹</label>
                       <select value={formData.fields.modelType} onChange={e => updateField('modelType', e.target.value)} className="w-full px-4 py-3 bg-white/50 border border-border-color rounded-xl">
                         <option value="gemini-3-pro">Gemini 3 Pro</option>
                         <option value="claude-sonnet-4.5">Claude Sonnet 4.5</option>
                         <option value="claude-haiku-4.5">Claude Haiku 4.5</option>
                       </select>
                    </div>
                    <TextAreaRow label="Role" value={formData.fields.promptRole} onChange={v => updateField('promptRole', v)} maxLength={2000} onClear={() => updateField('promptRole', '')} placeholder="Role setting..." />
                    <TextAreaRow label="Response Guideline" value={formData.fields.promptGuideline} onChange={v => updateField('promptGuideline', v)} maxLength={3000} onClear={() => updateField('promptGuideline', '')} placeholder="Guideline..." />
                    <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-xl text-sm">
                        <div className="text-text-main">é ä¼° Tokenï¼š{promptTokens}</div>
                    </div>
                </Section>
                
                <GameManagement data={formData.gameManagement} onChange={updateGameManagement} />

                <Section id="sec-first" title="é–‹å ´èˆ‡å°è©±" icon="ğŸ¬">
                    <TextAreaRow label="ç¬¬ä¸€æ¬¡èŠå¤©å ´æ™¯ (800å­—)" value={formData.fields.firstScene} onChange={v => updateField('firstScene', v)} maxLength={800} />
                    <TextAreaRow label="è§’è‰²å°è©±ç¯„ä¾‹ (800å­—)" value={formData.fields.sampleDialogue} onChange={v => updateField('sampleDialogue', v)} maxLength={800} />
                </Section>

                 <Section id="sec-fav" title="å–œå¥½èˆ‡ç”Ÿæ—¥" icon="ğŸ€">
                    <InputRow label="å–œæ­¡çš„æ±è¥¿ (50å­—)" value={formData.fields.likes} onChange={v => updateField('likes', v)} maxLength={50} />
                    <InputRow label="ä¸å–œæ­¡çš„æ±è¥¿ (50å­—)" value={formData.fields.dislikes} onChange={v => updateField('dislikes', v)} maxLength={50} />
                    <InputRow label="ç”Ÿæ—¥" type="date" value={formData.fields.birthday} onChange={v => updateField('birthday', v)} />
                </Section>

                <Section id="sec-extra" title="é™„åŠ è³‡è¨Š" icon="ğŸ“Œ">
                    <p className="text-sm text-text-sub mb-4">æœ€å¤š 10 ç­†ï¼Œæ¯ç­† 500 å­—ã€‚</p>
                    {formData.extras.map((extra, idx) => (
                        <div key={idx} className="mb-6 pl-4 border-l-4 border-border-color hover:border-focus transition-colors">
                            <InputRow label="æ¨™é¡Œ" value={extra.title} onChange={v => updateDynamicField('extras', idx, 'title', v)} maxLength={50} />
                            <TextAreaRow label={`é™„åŠ è³‡è¨Š ${idx + 1}`} value={extra.text} onChange={v => updateDynamicField('extras', idx, 'text', v)} maxLength={500} actions={<><TemplateSelector type="extra" currentValue={extra.text} onApply={v => updateDynamicField('extras', idx, 'text', v)} /><button onClick={() => removeDynamicField('extras', idx)} className="text-xs px-2 py-1 text-red-500 border border-red-200 rounded">åˆªé™¤</button></>} />
                        </div>
                    ))}
                    <button onClick={() => addDynamicField('extras')} className="w-full py-3 border-2 border-dashed border-border-color rounded-xl text-text-sub hover:border-focus hover:text-focus transition-colors">ï¼‹ æ–°å¢é™„åŠ è³‡è¨Š</button>
                </Section>

                <Section id="sec-event" title="å‰µä½œè€…äº‹ä»¶" icon="ğŸ“š">
                    <p className="text-sm text-text-sub mb-4">æœ€å¤š 20 ç­†ï¼Œæ¯ç­† 2000 å­—ã€‚</p>
                    {formData.events.map((evt, idx) => (
                        <div key={idx} className="mb-6 pl-4 border-l-4 border-border-color hover:border-focus transition-colors">
                            <InputRow label="æ¨™é¡Œ" value={evt.title} onChange={v => updateDynamicField('events', idx, 'title', v)} maxLength={50} />
                            <TextAreaRow label={`å‰µä½œè€…äº‹ä»¶ ${idx + 1}`} value={evt.text} onChange={v => updateDynamicField('events', idx, 'text', v)} maxLength={2000} actions={<><TemplateSelector type="event" currentValue={evt.text} onApply={v => updateDynamicField('events', idx, 'text', v)} /><button onClick={() => removeDynamicField('events', idx)} className="text-xs px-2 py-1 text-red-500 border border-red-200 rounded">åˆªé™¤</button></>} />
                        </div>
                    ))}
                    <button onClick={() => addDynamicField('events')} className="w-full py-3 border-2 border-dashed border-border-color rounded-xl text-text-sub hover:border-focus hover:text-focus transition-colors">ï¼‹ æ–°å¢å‰µä½œè€…äº‹ä»¶</button>
                </Section>

                <Section id="sec-output" title="è¼¸å‡ºèˆ‡é è¦½" icon="ğŸ“">
                     <div className="flex flex-col gap-4">
                        <div className="p-6 bg-white/60 dark:bg-gray-800/60 rounded-2xl border border-border-color">
                            <h3 className="font-bold mb-4">æ“ä½œ</h3>
                            <button onClick={exportMD} className="w-full mb-3 bg-btn-bg text-btn-text font-bold py-3 rounded-xl shadow-lg hover:brightness-110 transition-all">âœ¨ ä¸‹è¼‰è§’è‰²å¡ (.txt)</button>
                        </div>
                     </div>
                     <div className="mt-8">
                         <h3 className="font-bold mb-2">é è¦½ Markdown</h3>
                         <div className="bg-[#1e1e1e] text-gray-300 p-6 rounded-xl font-mono text-sm whitespace-pre-wrap border border-gray-700 shadow-inner h-96 overflow-y-auto">
                             {generateMarkdown(formData)}
                         </div>
                     </div>
                </Section>
                
                <Section id="sec-template-center" title="æ¨¡æ¿ç®¡ç†ä¸­å¿ƒ" icon="ğŸ§°">
                   <div className="grid md:grid-cols-2 gap-6">
                     {Object.keys(TEMPLATE_TYPES).map(type => (
                       <div key={type} className="bg-white/40 rounded-xl p-4 border border-border-color">
                          <h3 className="font-bold mb-3 border-b border-border-color pb-2">{TEMPLATE_TYPES[type]}</h3>
                          {(store.templates[type] || []).map(tpl => (
                             <div key={tpl.id} className="bg-white p-3 rounded-lg shadow-sm flex justify-between items-center mb-2">
                               <div className="text-sm">{tpl.name}</div>
                               <button onClick={() => deleteTemplate(type, tpl.id)} className="text-xs text-red-400 hover:text-red-600">åˆªé™¤</button>
                             </div>
                          ))}
                       </div>
                     ))}
                   </div>
                </Section>

              </main>
            </div>
            <button onClick={() => window.scrollTo({top:0, behavior:'smooth'})} className="fixed bottom-8 right-8 w-14 h-14 bg-btn-bg text-white rounded-full shadow-2xl flex items-center justify-center text-xl hover:-translate-y-1 transition-transform z-50">â–²</button>
          </div>
        </ThemeWrapper>
      );
    };

    const App = () => <ToastProvider><InnerApp /></ToastProvider>;
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
